<?php

namespace Core;

/**
 * Base View class
 */
class View
{
	/**
	 * View path of currently rendering View
	 *
	 * @var string
	 */
	private $views_path;

	/**
	 * The main content of the view which
	 * is rendedred and stored as a string
	 *
	 * @var string
	 */
	private $content;

	/**
	 * Stores named section's rendered content
	 *
	 * @var array
	 */
	private $section;

	/**
	 * Full path of template while which is used
	 * by current view.
	 *
	 * @var string
	 */
	private $template = "";

	/**
	 * Any arguments to the template file is
	 * stored in this var.
	 * Example : argument like "title" of the page
	 * "title" => "Contact page"
	 *
	 * @var array  Associative array
	 */
	private $template_args;

	/**
	 * Keep track of currently rendering section.
	 * So if a section is currently in process
	 * then no new section will be rendered, if so,
	 * then exception is raised.
	 * It prevents from nesting of section.
	 *
	 * @var string  Name of the currently rendering section
	 */
	private $present_rendering_section = "";

	/**
	 * Constructor to instantiate the class
	 *
	 * @param string  Views path
	 */
	public function __construct($view_path)
	{
		$this->views_path = $view_path;
	}

	/**
	 * Render a view file
	 *
	 * @param string $view  The  view file
	 * @return void
	 */
	public function render($view, $args = [])
	{
		$file = $this->views_path . DS . $view;	

		if(is_readable($file))
		{
			$this->content = $this->renderView($file, $args);

			if ($this->isTemplateUsed()) {
				$this->renderTemplate();
			}
		}
		else
		{
			throw new \Exception("$file not found!");
		}
	}

	/**
	 * Defines which template file to use
	 *
	 * @var string $template  The path to template file relative to Views dir.
	 * @var array $args  Pass the arguments to template file.
	 * @return void
	 */
	public function use($template, array $args = array())
	{
		if (! is_readable($this->views_path . DS . $template)) {
			throw new \Exception("Template file $template not found!");
		}

		$this->template = $this->views_path . DS . $template;
		$this->template_args = $args;
	}

	/**
	 * Returns the main content of a view
	 * It should be used only when we don't
	 * define and use the section() method in main view file.
	 * Then any left over or undefined html/php content will be
	 * treated as content of the view.
	 *
	 * @return string
	 */
	public function content()
	{
		return $this->content;
	}

	/**
	 * Defines section of the view file and starts the
	 * output buffer.
	 * Used to mark the starting of the section.
	 *
	 * @var string $section  The name of the section
	 * @return void
	 */
	public function section($section)
	{
		if ($this->present_rendering_section) {
			throw new \Exception("A Section is already in rendering progress. Section can not be nested.");
		}

		$this->present_rendering_section = $section;
		ob_start();
	}

	/**
	 * Stops and cleans the output buffer.
	 * Used to mark the end of the last started section.
	 *
	 * @return void
	 */
	public function endSection()
	{
		if (! $this->present_rendering_section) {
			throw new \Exception("You are ending a section which is never began.");
		}

		$this->section[$this->present_rendering_section] = ob_get_clean();
		$this->present_rendering_section = "";
	}

	/**
	 * Fetches rendered section and injects it where this
	 * method is used.
	 *
	 * @var string $section  Name of the section to be fetched
	 * @return string
	 */
	public function fetchSection($section)
	{
		if (! isset($this->section[$section])) {
			return "";
		}

		return $this->section[$section];
	}


	/**
	 * Renders the template file.
	 * It sends the rendered final output to client
	 *
	 * @return void
	 */
	protected function renderTemplate()
	{
		$ob_level = ob_get_level();
		extract($this->template_args);

		ob_start();

		try {

			include $this->template;

		} catch (\Exception $e) {

			$this->handleException($e, $ob_level);

		}

		////////////////////////
		// NEED TO WORK ON IT.
		// MAKE IT EFFICIENT IN MEMORY USEAGE.
		// LEARN BUFFER STACKING FOR RESPONDING HTML
		////////////////////////

		ob_end_flush();
	}

	/**
	 * Renders a given view
	 *
	 * @var string $view  Path to view file
	 * @var array $args  Pass the arguments to view file
	 */
	protected function renderView($view, $args = array())
	{
		////////////////////////
		// TODO
		// Catch any exception generated by the include file.
		// and handle it properly, and don't allow the
		// leaking of partial view to client.
		////////////////////////

		$ob_level = ob_get_level();
		extract($args, EXTR_SKIP);

		ob_start();

		try {
			// echo $view;
			include $view;
			// throw new \Exception("Exception raised from try block.");

		} catch (Exception $e) {

			$this->handleException($e, $ob_level);
		}


		return ob_get_clean();
	}

	/**
	 * Handles any Exception raised in the view file.
	 *
	 * @var \Exception $e  Exception object
	 * @var int $ob_level  Current level of the output buffer
	 * @return \Exception
	 */
	protected function handleException($e, $ob_level)
	{
		while (ob_get_level() > $ob_level) {
			ob_end_clean();
		}

		throw $e;
	}

	/**
	 * Output method to escape output
	 *
	 * @var string $data  Data to be escaped
	 * @return string  Escaped string
	 */
	public function escape($data = "")
	{
		if (! $data) {
			return "";
		}

		return e($data);
	}

	/**
	 * Alias for the escape() method
	 *
	 * @var string $data  Data to be escaped
	 * @return string  Escaped string
	 */
	public function e($data = "")
	{
		return $this->escape($data);
	}

	/**
	 * Checks if template is used in the view.
	 *
	 * @return bool
	 */
	protected function isTemplateUsed()
	{
		return $this->template !== "";
	}
}
